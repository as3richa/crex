#!/usr/bin/env ruby

module Spec
  def pattern(pat)
    raise "nested call to pattern" unless @active_pattern_id.nil?

    @active_pattern_id = patterns.size
    patterns << pat

    yield

    @active_pattern_id = nil
  end

  def testcase(str, groups)
    raise "call to testcase outside of pattern" if @active_pattern_id.nil?
    groups = { 0 => groups } if groups.is_a?(String) || groups.is_a?(Array)
    testcases << [@active_pattern_id, str, groups]
  end

  def emit(file)
    file.puts("#define N_PATTERNS #{patterns.size}")

    file.puts("const pattern_defn_t pattern_defns[N_PATTERNS] = {")
    file.puts(patterns.map { |pattern| "  {#{pattern.inspect}, #{pattern.size}}" }.join(",\n"))
    file.puts("};")

    file.puts("#define N_TESTCASES #{testcases.size}")

    serialized_cases = testcases.map do |pattern_id, str, groups|
      if groups.nil?
        groups_ary = [[0xffffffff, 0xffffffff]]
      else
        groups_ary = [[0xffffffff, 0xffffffff]] * (groups.keys.max + 1)

        groups.each do |index, substr|
          if substr.is_a?(Array)
            position = substr[1]
            substr = substr[0]
          else
            position = str.index(substr)
          end

          raise "bad test data" unless str[position, substr.length] == substr

          groups_ary[index] = [position, position + substr.length]
        end
      end

      serialized_groups = groups_ary.map { |position, finish| "{#{position}, #{finish}}"}.join(', ')

      "  {#{pattern_id}, #{str.inspect}, #{str.size}, #{groups.nil? ? 0 : 1}, {#{serialized_groups}}}"
    end

    file.puts("const testcase_t testcases[N_TESTCASES] = {")
    file.puts(serialized_cases.join(",\n"))
    file.puts("};")
  end

  private

  def patterns
    @patterns ||= []
  end

  def testcases
    @testcases ||= []
  end
end

include Spec

if ARGV.length != 2
  $stderr.puts("usage: #{$0} <output file> <dependency file>")
  exit(1)
end

dirname = File.dirname(__FILE__)

deps = [__FILE__]

Dir.glob(File.join(__dir__, '*.rb')) do |path|
  filename = File.basename(path)
  deps << File.join(dirname, filename)
  require_relative(filename)
end

begin
  emit(File.open(ARGV[0], 'w'))
rescue StandardError
  File.delete(ARGV[0])
  raise
end

File.write(ARGV[1], "#{ARGV[0]}: #{deps.join(' ')}\n")
